[{"title":"angular-mocks","date":"2017-05-15T15:06:13.000Z","path":"2017/05/15/angular-mocks/","text":"安装 引入 使用 angular-mocks前后端分离的开发模式中, 为了能让前端不依赖后端服务而能够并行开发, angular-mocks能模拟一些后台返回的数据,从而使前端看起来已经跟后端对接了一样, 只要与后端商定好数据格式, 自己mock一些数据就能够对前端功能进行测试了. 1. 安装 bower install angular-mocks@X.Y.Z (X、Y、Z为你需要的AngularJS版本号。) 2. 引入在angular启动模块中引入ngMockE2E模块 1234angular.module('myApp', [ 'ngMockE2E', 'myApp.mock']) 其中, ‘myApp.mock’是自定义的用来mock数据的模块. 3. 使用‘myApp.mock’模块: 12345678910111213angular.module('myApp.mock', []) .run([\"$httpBackend\", \"$rootScope\", \"$http\", function ($httpBackend, $rootScope, $http) &#123; //对于html模板的请求不拦截 $httpBackend.whenGET(/views\\/(.+).html/).passThrough(); $httpBackend.whenPOST(/\\/meta\\/module\\/config\\/delete/).respond(200, &#123; \"success\": true, \"code\": 200, \"message\": \"\", \"data\": \"1\" &#125;); &#125;); 上面代码中用到了两个方法:’whenGet’和’whenPost’,分别用于处理get和post请求, 事实上可以理解为这两个方法都是继承自when方法: 1$httpBackend.when = function(method, url, data, headers, keys) ‘whenGet’和’whenPost’只是给参数method设置了默认值, 从when方法中可以看出, 它允许你指定以什么方式(method),带着什么请求头(headers) 向哪个url(url)发送了什么数据(data), keys接受一个数组, 用于跟url进行正则匹配. 接下来链式调用一个方法respond(), 用于设置希望返回的数据. 1234567chain = &#123; respond: function(status, data, headers, statusText) &#123; definition.passThrough = undefined; definition.response = createResponse(status, data, headers, statusText); return chain; &#125;&#125;; 从方法定义中可以看出能够为返回数据指定状态码, 数据实体, 返回头, 以及状态文本. 定义好’myApp.mock’模块之后, 发请求的时候就会被angular-mock拦截, 若定义了被请求的url返回数据, 则会正常返回, 未定义则会抛出异常: 1Error: Unexpected request: GET views/base/base.html(…) &quot;Possibly unhandled rejection: &#123;&#125;&quot;","comments":true,"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://zxmantou.github.io/tags/angularjs/"},{"name":"mock","slug":"mock","permalink":"https://zxmantou.github.io/tags/mock/"}]},{"title":"pyenv && virtualenv","date":"2017-05-15T15:04:12.000Z","path":"2017/05/15/pyenv-virtualenv/","text":"安装1.1 自动安装1.2 手动安装 常用命令 pyenv 插件: pyenv-virtualenv 1. 安装1.1 自动安装：1curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash 1.2 手动安装a. 将 pyenv 检出到你想安装的目录。建议路径为：$HOME/.pyenv 12$ cd$ git clone git://github.com/yyuu/pyenv.git .pyenv b. 添加环境变量。PYENV_ROOT指向 pyenv检出的根目录，并向$PATH添加$PYENV_ROOT/bin以提供访问pyenv这条命令的路径 12$ echo &apos;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&apos; &gt;&gt; ~/.bash_profile$ echo &apos;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&apos; &gt;&gt; ~/.bash_profile c. 向 shell 添加pyenv init以启用 shims 和命令补完功能 1$ echo &apos;eval &quot;$(pyenv init -)&quot;&apos; &gt;&gt; ~/.bash_profile 配置文件的位置同上一条一样需要修改 d. 重启 shell（因为修改了$PATH） 1$ exec $SHELL 2. 常用命令：a. pyenv versions 查看已安装的python版本 b. Pyenv install -l 列出所有pyenv收录的python版本 c. pyenv install -v {version} 安装指定版本 d. Pyenv uninstall {version} 卸载指定版本 e. pyenv rehash - 创建垫片路径（为所有已安装的可执行文件 （如：~/.pyenv/versions//bin/） 创建 shims，因此，每当你增删了 Python 版本或带有可执行文件的包（如 pip）以后，都应该执行一次本命令） f. $ pyenv global 3.4.0 - 设置全局的 Python 版本，通过将版本号写入 ~/.pyenv/version 文件的方式。 g. $ pyenv local 2.7.3 - 设置面向程序的本地版本，通过将版本号写入当前目录下的 .python-version 文件的方式。通过这种方式设置的 Python 版本优先级较 global 高。 h. pyenv 会从当前目录开始向上逐级查找 .python-version 文件，直到根目录为止。若找不到，就用 global 版本。 3. pyenv 插件: pyenv-virtualenva. 创建虚拟环境 1$ pyenv virtualenv 2.7.10 my-virtual-env-2.7.10 若不指定python 版本，会汇报认使用当前环境python版本。 b. 列出当前虚拟环境 1pyenv virtualenvs c. 激活虚拟环境 1pyenv activate d. 退出虚拟环境 1pyenv deactivate e. 删除虚拟环境 1pyenv uninstall my-virtual-env","comments":true,"tags":[{"name":"python","slug":"python","permalink":"https://zxmantou.github.io/tags/python/"},{"name":"pyenv","slug":"pyenv","permalink":"https://zxmantou.github.io/tags/pyenv/"},{"name":"virtualenv","slug":"virtualenv","permalink":"https://zxmantou.github.io/tags/virtualenv/"}]},{"title":"使用$http发送请求的时候显示loading","date":"2017-05-15T15:01:37.000Z","path":"2017/05/15/angularjs-http-loading/","text":"通过拦截$http请求统一添加loading图片 由于是单页应用, 所以在index.html中必有这样一行:1&lt;div ui-view=&quot;&quot;&gt;&lt;/div&gt; 在这一行下面添加以下代码: 12345&lt;div id=\"loading\" ng-show=\"showLoading\"&gt; &lt;div class=\"spinner\"&gt; &lt;img src=\"images/loading.gif\" style=\"z-index: 999\"&gt; &lt;/div&gt;&lt;/div&gt; CSS: 123456789101112131415161718192021#loading &#123; position: fixed; /* Sit on top of the page content */ display: block; /* Hidden by default */ width: 100%; /* Full width (cover the whole page) */ height: 100%; /* Full height (cover the whole page) */ top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.5); /* Black background with opacity */ z-index: 2000; /* Specify a stack order in case you&apos;re using a different order for other elements */ cursor: pointer; /* Add a pointer on hover */&#125;.spinner &#123; margin: 0 auto; position: relative; top: 35%; width: 1px; z-index: 2147483647;&#125; 不要忘了给body添加属性: 1&lt;body ng-class=&quot;&#123;true: &apos;modal-open&apos;, false: &apos;&apos;&#125;[showLoading]&quot;&gt; 若不启动蒙版, 显示loading 的时候依然能够在页面上操作, 因为用了bootstrap, 所以添加modal-open就能够开启蒙版了. JS: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051angular.module(&apos;listener&apos;, []) .run([&quot;$rootScope&quot;, &apos;$injector&apos;, function ($rootScope, $injector) &#123; $rootScope.showLoading = false; $rootScope.$on(&apos;loading:show&apos;, function () &#123; $rootScope.showLoading = true; &#125;); $rootScope.$on(&apos;loading:hide&apos;, function () &#123; $rootScope.showLoading = false; &#125;); $rootScope.$on(&apos;request:404&apos;, function () &#123; swal(&#123; title: &quot;请求出错!&quot;, type: &quot;error&quot;, timer: 1000, showConfirmButton: false, allowOutsideClick:true &#125;); &#125;); &#125;] );angular.module(&apos;interceptor&apos;, []) .config([&apos;$httpProvider&apos;, function ($httpProvider) &#123; var requestInterceptor = [&apos;$q&apos;, &apos;$injector&apos;, &apos;$rootScope&apos;, function ($q, $injector, $rootScope) &#123; return &#123; request: function (config) &#123; $rootScope.$broadcast(&apos;loading:show&apos;); return config || $q.when(config); &#125;, response: function (response) &#123; $rootScope.$broadcast(&apos;loading:hide&apos;); return response; &#125;, responseError: function (response) &#123; $rootScope.$broadcast(&apos;loading:hide&apos;); return $q.reject(response); &#125;, requestError: function (response) &#123; $rootScope.$broadcast(&apos;loading:hide&apos;); return response; &#125; &#125;; &#125;]; $httpProvider.interceptors.push(requestInterceptor); &#125;]); 另附生成loading图片的地址:https://loading.io[/](https://loading.io/)","comments":true,"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://zxmantou.github.io/tags/angularjs/"},{"name":"loading","slug":"loading","permalink":"https://zxmantou.github.io/tags/loading/"}]},{"title":"Springmvc+mybatis 多数据源的两种用法","date":"2017-05-15T14:48:31.000Z","path":"2017/05/15/springmvc-mybatis-multi-datasource/","text":"1. 使用AOP动态切换2. 设置多个sqlSessionFactory 1. 使用AOP动态切换这种情况常见于主从库读写分离的时候, 通常一个mapper会用到至少两个库, 在select和insert、update的时候分别使用不同的库, 此时建议使用AOP. spring-mybatis.xml:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;bean id=&quot;readDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;jdbc.initialSize&#125;&quot;/&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;jdbc.maxActive&#125;&quot;/&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;jdbc.maxIdle&#125;&quot;/&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;jdbc.minIdle&#125;&quot;/&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;$&#123;jdbc.maxWait&#125;&quot;/&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;300000&quot;/&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;600000&quot;/&gt; &lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;$&#123;jdbc.maxActive&#125;&quot;/&gt; &lt;property name=&quot;validationQuery&quot; value=&quot;select 1&quot;/&gt; &lt;/bean&gt;&lt;bean id=&quot;writeDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;analyze.jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;analyze.jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;analyze.jdbc.password&#125;&quot; /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;jdbc.initialSize&#125;&quot;/&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;jdbc.maxActive&#125;&quot;/&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;jdbc.maxIdle&#125;&quot;/&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;jdbc.minIdle&#125;&quot;/&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;$&#123;jdbc.maxWait&#125;&quot;/&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;300000&quot;/&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;600000&quot;/&gt; &lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;$&#123;jdbc.maxActive&#125;&quot;/&gt; &lt;property name=&quot;validationQuery&quot; value=&quot;select 1&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.abc.dao.DBContextHolder&quot;&gt;&lt;!-- 这里写选择数据源的类地址 下面跟着给出--&gt; &lt;property name=&quot;defaultTargetDataSource&quot; ref=&quot;readDataSource&quot;/&gt;&lt;!-- 设置默认为此readDataSource数据源--&gt; &lt;property name=&quot;targetDataSources&quot;&gt; &lt;map&gt; &lt;entry key=&quot;readDataSource&quot; value-ref=&quot;readDataSource&quot;/&gt; &lt;entry key=&quot;writeDataSource&quot; value-ref=&quot;writeDataSource&quot;/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mapping/**/*.xml&quot;/&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:config/mybatis-config.xml&quot; /&gt;&lt;/bean&gt;&lt;!--配置aop--&gt;&lt;bean id=&quot;dataSourceAspect&quot; class=&quot;com.abc.dao.DataSourceAspect&quot; /&gt;&lt;aop:config&gt; &lt;aop:advisor pointcut=&quot;execution(* com.abc.dao..*.*(..))&quot; advice-ref=&quot;dataSourceAspect&quot; /&gt;&lt;/aop:config&gt; DBContextHolder123456789101112131415161718192021222324252627282930313233public class DBContextHolder extends AbstractRoutingDataSource &#123; public static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;String&gt;(); /** * 设置当前数据源 * @param dbType */ public static void setDbType(String dbType)&#123; if(!dbType.equals(getDbType()))&#123; contextHolder.set(dbType); &#125; &#125; /** * 获得当前数据源 * @return */ public static String getDbType()&#123; String dbType = (String)contextHolder.get(); return dbType; &#125; /** *清除上下文 * */ public static void clearContext()&#123; contextHolder.remove(); &#125; @Override protected Object determineCurrentLookupKey() &#123; return DBContextHolder.getDbType(); &#125;&#125; DataSourceAspect:12345678910111213141516171819202122232425262728293031323334public class DataSourceAspect implements MethodBeforeAdvice, AfterReturningAdvice, ThrowsAdvice &#123; private static final Logger log = LogManager.getLogger(DataSourceAspect.class); @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; &#125; @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; try &#123; if(method != null) &#123; //这里用于区分读和写的方法, 需按情况修改 if(method.getName().startsWith(&quot;select&quot;)) &#123; DBContextHolder.setDbType(&quot;readDataSource&quot;); &#125; else &#123; DBContextHolder.setDbType(&quot;writeDataSource&quot;); &#125; &#125; &#125; catch (Exception var5) &#123; log.error(&quot;data source aspect error.&quot;, var5); &#125; &#125; public void after(JoinPoint point) &#123; log.info(&quot;clear db type after method.current id &#123;&quot; + Arrays.toString(new Object[]&#123;Long.valueOf(Thread.currentThread().getId())&#125;) + &quot;&#125;&quot;); DBContextHolder.clearContext(); &#125; public void afterThrowing(Method method, Object[] args, Object target, Exception ex) throws Throwable &#123; log.info(&quot;current db type &#123;&quot; + Arrays.toString(new Object[]&#123;DBContextHolder.getDbType()&#125;) + &quot;&#125; when exception&quot;); DBContextHolder.setDbType(&quot;metaDataSource&quot;); &#125;&#125; 2. 设置多个sqlSessionFactory这种情况多见于一个系统集成了多种类型的功能, 需要多个数据连接, 这些数据连接甚至连数据库类型都不同, 但是一个mapper肯定只会有其中的一个. 这种方法属于静态配置, 只需要指定什么mapper用什么数据连接即可 spring-mybatis.xml:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;bean id=&quot;analyzeDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;jdbc.initialSize&#125;&quot;/&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;jdbc.maxActive&#125;&quot;/&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;jdbc.maxIdle&#125;&quot;/&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;jdbc.minIdle&#125;&quot;/&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;$&#123;jdbc.maxWait&#125;&quot;/&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;300000&quot;/&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;600000&quot;/&gt; &lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;$&#123;jdbc.maxActive&#125;&quot;/&gt; &lt;property name=&quot;validationQuery&quot; value=&quot;select 1&quot;/&gt; &lt;/bean&gt;&lt;bean id=&quot;managementDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;analyze.jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;analyze.jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;analyze.jdbc.password&#125;&quot; /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;jdbc.initialSize&#125;&quot;/&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;jdbc.maxActive&#125;&quot;/&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;jdbc.maxIdle&#125;&quot;/&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;jdbc.minIdle&#125;&quot;/&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;$&#123;jdbc.maxWait&#125;&quot;/&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;300000&quot;/&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;600000&quot;/&gt; &lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;$&#123;jdbc.maxActive&#125;&quot;/&gt; &lt;property name=&quot;validationQuery&quot; value=&quot;select 1&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;sqlSessionFactoryAnalyze&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;analyzeDataSource&quot; /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mapping/analyze/**/*.xml&quot;/&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:config/mybatis-config.xml&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;sqlSessionFactoryManagement&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;managementDataSource&quot; /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mapping/management/**/*.xml&quot;/&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:config/mybatis-config.xml&quot; /&gt;&lt;/bean&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.abc.dao.analyze&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactoryAnalyze&quot;/&gt;&lt;/bean&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.abc.dao.management&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactoryManagement&quot;/&gt;&lt;/bean&gt; 注意, 上面配置了两次MapperScannerConfigurer, 前者会优先匹配, 后者不会覆盖前者 这种方式配置文件完成, 多数据源配置也就完成了","comments":true,"tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://zxmantou.github.io/tags/springmvc/"},{"name":"mybatis","slug":"mybatis","permalink":"https://zxmantou.github.io/tags/mybatis/"},{"name":"多数据源","slug":"多数据源","permalink":"https://zxmantou.github.io/tags/多数据源/"}]},{"title":"MongoDB备份与恢复","date":"2017-04-07T00:45:44.000Z","path":"2017/04/07/MongoDB3/","text":"介绍MongoDB整库备份与恢复的方法 1. 备份 mongodump用法: mongodump 将mongodb里的数据导出为.bson文件 常用配置: 参数 用法 /help 打印帮助 /version 打印工具版本 /v, /verbose: 指定日志(v的数量代表了日志级别, 如:-vvvv, 也可以指定数字, 如:–verbose=N) /quiet 静默执行, 不打印任何日志输出 /h, /host: 指明数据库服务器的IP /port: 服务端口 (也可以这么用 –host hostname:port) /u, /username: 连接服务器的用户名 /p, /password: 连接数据库的密码 /authenticationDatabase: 存储用户凭据的数据库 /authenticationMechanism: 认证机制 /d, /db: 将要备份的数据库 /c, /collection: 将要备份的集合(数据表) /o, /out: 备份文件输出路径, 默认路径是bin下的dump 或者指定为’-‘ 表示输出到控制台(例: -o -) 2. 恢复 mongorestore用法: mongorestore 常用配置: 同上 3. 其他方法有时别人会把整个MongoDB的数据文件发给你, 这种”备份”方式很不推荐, 因为这样很有可能在复制文件的时候有更新操作, 导致拿到的文件时不完整的, 从而无法恢复. 使用上述备份与恢复方法可以避免这个问题. 如果拿到的是数据文件: 首先看是否有.wt文件, 如果有, 则说明原始库用的是WiredTiger引擎, 如果你的MongoDB是3.2以上版本, 则默认就是WiredTiger引擎, 无需额外加参数. 如果没有.wt文件, 而是有xxx.ns和xxx.0 xxx.1等文件, 则说明用的是mmap引擎, 3.2一下版本默认就是这个引擎, 而3.2以上版本需要指定参数:–storageEngine=mmapv1 然后看文件夹中是不是每个数据库都有自己的子文件夹, 这将决定启动mongod的时候是否需要加参数–directoryperdb, 有子文件夹则需要加这个参数, MongoDB将会去相应的子文件夹中读取数据文件 最后别忘了加参数–dbpath用于指定你所拿到备库文件夹的路径","comments":true,"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://zxmantou.github.io/tags/MongoDB/"}]},{"title":"MongoDB增删改——我们所熟悉的操作","date":"2017-04-07T00:43:48.000Z","path":"2017/04/07/MongoDB2/","text":"前面介绍了如何启动MongoDB以及用shell连接, 下面介绍一些我们在mysql中所熟悉的一些操作 创建数据库 MongoDB 创建数据库的语法格式如下： 1use DATABASE_NAME 如果数据库不存在，则创建数据库，否则切换到指定数据库。 演示 12345&gt; use zxmantouswitched to db zxmantou&gt; dbzxmantou&gt; 可见我们当前的db已经是zxmantou了, 使用show dbs命令查看数据库列表 1234&gt; show dbsadmin 0.000GBlocal 0.000GBtest 0.000GB 发现新增的数据库并不在其中. 要显示它，我们需要向 zxmantou 数据库插入一些数据。 12345678&gt; db.user.insert(&#123;name:&quot;zxmantou&quot;&#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; show dbsadmin 0.000GBlocal 0.000GBtest 0.000GBzxmantou 0.000GB&gt; 删除数据库 删除当前数据库，默认为 test, 下面实例中将删除我们新建的zxmantou库: 12345678910111213&gt; show dbsadmin 0.000GBlocal 0.000GBtest 0.000GBzxmantou 0.000GB&gt; dbzxmantou&gt; db.dropDatabase()&#123; &quot;dropped&quot; : &quot;zxmantou&quot;, &quot;ok&quot; : 1 &#125;&gt; show dbsadmin 0.000GBlocal 0.000GBtest 0.000GB 删除集合(删除数据表) 集合删除语法格式如下： 1db.COLLECTION_NAME.drop() 实例: 12345678&gt; use zxmantouswitched to db zxmantou&gt; show tablesuser&gt; db.user.drop()true&gt; show tables&gt; 插入文档(新增记录) MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下： 1db.COLLECTION_NAME.insert(document) 实例: 12345678910111213&gt; use zxmantouswitched to db zxmantou&gt; db.user.insert(&#123;... name:&quot;zxmantou&quot;,... age:&quot;27&quot;,... gender: &quot;male&quot;,... site: &quot;www.zhangyuxiaojiao.com&quot;... &#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; db.user.find()&#123; &quot;_id&quot; : ObjectId(&quot;58e4d75bbe3140034aeb2ba1&quot;), &quot;name&quot; : &quot;zxmantou&quot;, &quot;age&quot; : &quot;27&quot;, &quot;gender&quot; : &quot;male&quot;, &quot;site&quot; : &quot;www.zhangyuxiaojiao.com&quot; &#125;&gt; 以上实例中 user 是我们的集合名(数据表名)，如果该集合不在该数据库中， MongoDB 会自动创建该集合并插入文档(一行记录)。 更新文档(更新记录) MongoDB 使用 update() 和 save() 方法来更新集合中的文档。接下来让我们详细来看下两个函数的应用及其区别。 5.1 Update()方法: update() 方法用于更新已存在的文档。语法格式如下： 123456789db.COLLECTION_NAME.update( &lt;query&gt;, &lt;update&gt;, &#123; upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 参数说明： query : update的查询条件，类似sql update查询内where后面的。 update : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的 upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。 multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 writeConcern :可选，抛出异常的级别。 我们刚才已经插入了一条记录, 现在对其进行修改: 1234567891011121314&gt; db.user.find()&#123; &quot;_id&quot; : ObjectId(&quot;58e4d75bbe3140034aeb2ba1&quot;), &quot;name&quot; : &quot;zxmantou&quot;, &quot;age&quot; : &quot;27&quot;, &quot;gender&quot; : &quot;male&quot;, &quot;site&quot; : &quot;www.zhangyuxiaojiao.com&quot; &#125;&gt; db.user.update(&#123;&apos;name&apos;:&apos;zxmantou&apos;&#125;,&#123;$set:&#123;&apos;age&apos;:18&#125;&#125;)WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)&gt; db.user.find().pretty()&#123; &quot;_id&quot; : ObjectId(&quot;58e4d75bbe3140034aeb2ba1&quot;), &quot;name&quot; : &quot;zxmantou&quot;, &quot;age&quot; : 18, &quot;gender&quot; : &quot;male&quot;, &quot;site&quot; : &quot;www.zhangyuxiaojiao.com&quot;&#125;&gt; 可见年龄已经年轻到18岁啦~ 5.2 save() 方法 save() 方法通过传入的文档来替换已有文档。语法格式如下： 123456db.collection.save( &lt;document&gt;, &#123; writeConcern: &lt;document&gt; &#125; ) 参数说明： document : 文档数据。 writeConcern :可选，抛出异常的级别。 实例 以下实例中我们替换了 _id 为 58e4d75bbe3140034aeb2ba1 的文档数据： 1234567891011121314151617&gt; db.user.save(&#123;... &quot;_id&quot; : ObjectId(&quot;58e4d75bbe3140034aeb2ba1&quot;),... &quot;name&quot; : &quot;zhangyuxiaojiao&quot;,... &quot;gender&quot; : &quot;male&quot;,... &quot;age&quot; : &quot;27&quot;,... &quot;site&quot; : &quot;zxmantou.github.io&quot;... &#125;)WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)&gt; db.user.find().pretty()&#123; &quot;_id&quot; : ObjectId(&quot;58e4d75bbe3140034aeb2ba1&quot;), &quot;name&quot; : &quot;zhangyuxiaojiao&quot;, &quot;gender&quot; : &quot;male&quot;, &quot;age&quot; : &quot;27&quot;, &quot;site&quot; : &quot;zxmantou.github.io&quot;&#125;&gt; 更多实例 只更新第一条记录： 1db.col.update( &#123; &quot;count&quot; : &#123; $gt : 1 &#125; &#125; , &#123; $set : &#123; &quot;test2&quot; : &quot;OK&quot;&#125; &#125; ); 全部更新： 1db.col.update( &#123; &quot;count&quot; : &#123; $gt : 3 &#125; &#125; , &#123; $set : &#123; &quot;test2&quot; : &quot;OK&quot;&#125; &#125;,false,true ); 只添加第一条： 1db.col.update( &#123; &quot;count&quot; : &#123; $gt : 4 &#125; &#125; , &#123; $set : &#123; &quot;test5&quot; : &quot;OK&quot;&#125; &#125;,true,false ); 全部添加加进去: 1db.col.update( &#123; &quot;count&quot; : &#123; $gt : 5 &#125; &#125; , &#123; $set : &#123; &quot;test5&quot; : &quot;OK&quot;&#125; &#125;,true,true ); 全部更新： 1db.col.update( &#123; &quot;count&quot; : &#123; $gt : 15 &#125; &#125; , &#123; $inc : &#123; &quot;count&quot; : 1&#125; &#125;,false,true ); 只更新第一条记录： 1db.col.update( &#123; &quot;count&quot; : &#123; $gt : 10 &#125; &#125; , &#123; $inc : &#123; &quot;count&quot; : 1&#125; &#125;,false,false ); 删除文档(删除记录) remove() 方法的基本语法格式如下所示： 1234567db.collection.remove( &lt;query&gt;, &#123; justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 参数说明： query :（可选）删除的文档的条件。 justOne : （可选）如果设为 true 或 1，则只删除一个文档。 writeConcern :（可选）抛出异常的级别。 实例: 123456789101112&gt; db.user.find().pretty()&#123; &quot;_id&quot; : ObjectId(&quot;58e4d75bbe3140034aeb2ba1&quot;), &quot;name&quot; : &quot;zhangyuxiaojiao&quot;, &quot;gender&quot; : &quot;male&quot;, &quot;age&quot; : &quot;27&quot;, &quot;site&quot; : &quot;zxmantou.github.io&quot;&#125;&gt; db.user.remove(&#123;&apos;name&apos;:&apos;zhangyuxiaojiao&apos;&#125;)WriteResult(&#123; &quot;nRemoved&quot; : 1 &#125;)&gt; db.user.find().pretty()&gt; 如果你想删除所有数据，可以使用以下方式（类似常规 SQL 的 truncate 命令）： 1&gt;db.col.remove(&#123;&#125;) 查询文档(查询记录) 之前实例已经演示了通过find()方法来查询所有记录的方法, 下一篇内容中将详细介绍复杂的查询方法","comments":true,"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://zxmantou.github.io/tags/MongoDB/"}]},{"title":"MongoDB安装与启动","date":"2017-04-07T00:41:59.000Z","path":"2017/04/07/MongoDB1/","text":"MongoDB安装与启动 1. 安装1.1 windows版 点击https://www.mongodb.com/download-center?jmp=nav#community到mongodb官网上下载msi文件. 双击运行即可, 没有什么需要交代的. 1.2 Linux版 123curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.3.tgz # 下载tar -zxvf mongodb-linux-x86_64-3.4.3.tgz # 解压mv mongodb-linux-x86_64-3.4.3/ /usr/local/mongodb MongoDB 的可执行文件位于 bin 目录下，所以可以将其添加到 PATH 路径中： 1export PATH=/usr/local/mongodb/bin:$PATH 1.3 Mac版mac版有两种方式, 一种是跟linux一样, 下载地址在此.另一种是通过brew安装: 1sudo brew install mongodb 如果要安装支持 TLS/SSL 命令如下： 1sudo brew install mongodb --with-openssl 安装最新开发版本： 1sudo brew install mongodb --devel 2. 启动MongoDB服务(以windows为例)安装完后文件目录如下: 12345678910111213141516171819202122232425262728D:\\Program Files\\MongoDB\\Server&gt;tree /a /f文件夹 PATH 列表卷序列号为 000D-76A0D:.\\---3.4 | GNU-AGPL-3.0 | MPL-2 | README | THIRD-PARTY-NOTICES | \\---bin bsondump.exe libeay32.dll mongo.exe mongod.exe mongod.pdb mongodump.exe mongoexport.exe mongofiles.exe mongoimport.exe mongooplog.exe mongoperf.exe mongorestore.exe mongos.exe mongos.pdb mongostat.exe mongotop.exe ssleay32.dll 首先创建一个用于存放MongoDB数据的文件夹, 我创建了一个文件夹 F:\\mongodb, 然后定位到mongodb的bin文件夹, 执行命令 1mongod --dbpath=f:\\mongodb 其中dbpath则是用于指定存放数据的路径, 这样mongodb服务便启动了. 此时新开一个cmd, 输入mongo打开shell, 其实这个shell就是mongodb的客户端，同时也是一个js的编译器，默认连接的是“test”数据库。 1234567D:\\Program Files\\MongoDB\\Server\\3.4\\bin&gt;mongoMongoDB shell version v3.4.3connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.3&gt; dbtest&gt; 3. 访问控制注意开启MongoDB服务时有一个waring: 122017-04-05T18:45:08.793+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2017-04-05T18:45:08.793+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted. 这是由于服务启动的时候没有开启访问控制(认证、授权)，如果是在学习阶段可以忽略这个警告，生产环境则需要开启访问控制：1mongod --auth --dbpath=f:\\mongodb 添加用户(需要在没开启访问控制的时候操作): 12345678use admindb.createUser(... &#123;... user: &quot;test&quot;,... pwd: &quot;test&quot;,... roles: [ &#123; role: &quot;__system&quot;, db: &quot;admin&quot; &#125; ]... &#125;... ) 这时使用–auth开启服务, 执行: 1db.auth(&quot;test&quot;,&quot;test&quot;) 即可继续操作数据库了 4. MongoDb web 用户界面MongoDB 提供了简单的 HTTP 用户界面。 如果你想启用该功能，需要在启动的时候指定参数 –rest 。1mongod --dbpath=f:\\mongodb --rest MongoDB 的 Web 界面访问端口比服务的端口多1000。如果你的MongoDB运行端口使用默认的27017，你可以在端口号为28017访问web用户界面，即地址为：http://localhost:28017。","comments":true,"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://zxmantou.github.io/tags/MongoDB/"}]},{"title":"SpringMVC + Shiro 访问未授权页面时不跳转，页面打印抛异常","date":"2016-06-08T02:38:00.000Z","path":"2016/06/08/SpringMVC-Shiro-UnauthorizedException/","text":"描述：配置文件中配置了访问了未授权之后的跳转地址，但结果没能跳转过去，而是直接在页面上抛出未授权异常 分析原因：配置文件可能需要做额外的处理 最终解决方案： 方案1：12345678&lt;!-- 定义需要特殊处理的异常，用类名或完全路径名作为key，异常页名作为值 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;org.apache.shiro.authz.UnauthorizedException&quot;&gt;/Denied&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 方案2：不使用注解，而是用配置文件配置url的权限 12345678910111213141516&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;!-- Shiro的核心安全接口，这个属性是必须的 --&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;!-- 要求登录时的链接(登录页面地址)，非必须的属性，默认会自动寻找Web工程根目录下的&quot;/login.jsp&quot;页面 --&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/showLogin&quot;/&gt; &lt;!-- 登录成功后要跳转的连接(本例中此属性用不到，因为登录成功后的处理逻辑在LoginController里硬编码) --&gt; &lt;!-- &lt;property name=&quot;successUrl&quot; value=&quot;/&quot; &gt;&lt;/property&gt; --&gt; &lt;!-- 用户访问未对其授权的资源时，所显示的连接 但是使用注解的话这段不起作用，需要使用异常处理器重定向页面--&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/denied&quot;/&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /Admin=roles[admin] /Common=roles[user] &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 原因：shiro的源代码ShiroFilterFactoryBean.Java定义的filter必须满足filter instanceof AuthorizationFilter，只有perms，roles，ssl，rest，port才是属于AuthorizationFilter，而anon，authcBasic，auchc，user是AuthenticationFilter，所以unauthorizedUrl设置后页面不跳转Shiro注解模式下，登录失败与没有权限都是通过抛出异常。并且默认并没有去处理或者捕获这些异常。在SpringMVC下需要配置捕获相应异常来通知用户信息","comments":true,"tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://zxmantou.github.io/tags/springmvc/"},{"name":"shiro","slug":"shiro","permalink":"https://zxmantou.github.io/tags/shiro/"}]},{"title":"BigDecimal 乘法问题","date":"2016-05-17T08:50:20.000Z","path":"2016/05/17/BigDecimal-multiply/","text":"直接用我的代码和结果描述一下问题吧： 代码：12345678910/** * Created by zhangx-ae on 2016/5/17. */public class DemoTest &#123; public static void main(String[] args) &#123; BigDecimal a = new BigDecimal(1000000); BigDecimal b = a.multiply(new BigDecimal(0.21)); System.out.println(b); &#125;&#125; 结果： 1209999.9999999999922284388276239042170345783233642578125000000 我想要的结果是210000.00，应该如何处理结果呢？ 实际上这是BigDecimal将double转化为Bigdecimal时出的问题，这是因为0.21不能够精确的表示double值，使用BigDecimal将double转化为精确值的时候所得的结果就会是0.2099999999999999922284388276239042170345783233642578125，所以相乘以后结果会是那个样子。 将String转为BigDecimal的时候，字符串是多少，结果就是多少，因此想要将double类型的数据转为BigDecimal的时候，这样做也许才是你想要的结果： 1BigDecimal b = new BigDecimal(String.valueOf(0.21)); 结果： 1210000.00","comments":true,"tags":[{"name":"BigDecimal","slug":"BigDecimal","permalink":"https://zxmantou.github.io/tags/BigDecimal/"}]}]