[{"title":"SpringMVC + Shiro 访问未授权页面时不跳转，页面打印抛异常","date":"2016-06-08T02:38:00.000Z","path":"2016/06/08/SpringMVC-Shiro-UnauthorizedException/","text":"描述：配置文件中配置了访问了未授权之后的跳转地址，但结果没能跳转过去，而是直接在页面上抛出未授权异常 分析原因：配置文件可能需要做额外的处理 最终解决方案： 方案1：12345678&lt;!-- 定义需要特殊处理的异常，用类名或完全路径名作为key，异常页名作为值 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;org.apache.shiro.authz.UnauthorizedException&quot;&gt;/Denied&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 方案2：不使用注解，而是用配置文件配置url的权限 12345678910111213141516&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;!-- Shiro的核心安全接口，这个属性是必须的 --&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;!-- 要求登录时的链接(登录页面地址)，非必须的属性，默认会自动寻找Web工程根目录下的&quot;/login.jsp&quot;页面 --&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/showLogin&quot;/&gt; &lt;!-- 登录成功后要跳转的连接(本例中此属性用不到，因为登录成功后的处理逻辑在LoginController里硬编码) --&gt; &lt;!-- &lt;property name=&quot;successUrl&quot; value=&quot;/&quot; &gt;&lt;/property&gt; --&gt; &lt;!-- 用户访问未对其授权的资源时，所显示的连接 但是使用注解的话这段不起作用，需要使用异常处理器重定向页面--&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/denied&quot;/&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /Admin=roles[admin] /Common=roles[user] &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 原因：shiro的源代码ShiroFilterFactoryBean.Java定义的filter必须满足filter instanceof AuthorizationFilter，只有perms，roles，ssl，rest，port才是属于AuthorizationFilter，而anon，authcBasic，auchc，user是AuthenticationFilter，所以unauthorizedUrl设置后页面不跳转Shiro注解模式下，登录失败与没有权限都是通过抛出异常。并且默认并没有去处理或者捕获这些异常。在SpringMVC下需要配置捕获相应异常来通知用户信息","tags":[{"name":"springmvc","slug":"springmvc","permalink":"http://yoursite.com/tags/springmvc/"},{"name":"shiro","slug":"shiro","permalink":"http://yoursite.com/tags/shiro/"}]},{"title":"BigDecimal 乘法问题","date":"2016-05-17T08:50:20.000Z","path":"2016/05/17/BigDecimal-multiply/","text":"直接用我的代码和结果描述一下问题吧： 代码：12345678910/** * Created by zhangx-ae on 2016/5/17. */public class DemoTest &#123; public static void main(String[] args) &#123; BigDecimal a = new BigDecimal(1000000); BigDecimal b = a.multiply(new BigDecimal(0.21)); System.out.println(b); &#125;&#125; 结果： 1209999.9999999999922284388276239042170345783233642578125000000 我想要的结果是210000.00，应该如何处理结果呢？ 实际上这是BigDecimal将double转化为Bigdecimal时出的问题，这是因为0.21不能够精确的表示double值，使用BigDecimal将double转化为精确值的时候所得的结果就会是0.2099999999999999922284388276239042170345783233642578125，所以相乘以后结果会是那个样子。 将String转为BigDecimal的时候，字符串是多少，结果就是多少，因此想要将double类型的数据转为BigDecimal的时候，这样做也许才是你想要的结果： 1BigDecimal b = new BigDecimal(String.valueOf(0.21)); 结果： 1210000.00","tags":[{"name":"BigDecimal","slug":"BigDecimal","permalink":"http://yoursite.com/tags/BigDecimal/"}]}]