[{"title":"MongoDB备份与恢复","date":"2017-04-07T00:45:44.000Z","path":"2017/04/07/MongoDB3/","text":"MongoDB备份与恢复 1. 备份 mongodump用法: mongodump 将mongodb里的数据导出为.bson文件 常用配置: 参数 用法 /help 打印帮助 /version 打印工具版本 /v, /verbose: 指定日志(v的数量代表了日志级别, 如:-vvvv, 也可以指定数字, 如:–verbose=N) /quiet 静默执行, 不打印任何日志输出 /h, /host: 指明数据库服务器的IP /port: 服务端口 (也可以这么用 –host hostname:port) /u, /username: 连接服务器的用户名 /p, /password: 连接数据库的密码 /authenticationDatabase: 存储用户凭据的数据库 /authenticationMechanism: 认证机制 /d, /db: 将要备份的数据库 /c, /collection: 将要备份的集合(数据表) /o, /out: 备份文件输出路径, 默认路径是bin下的dump 或者指定为’-‘ 表示输出到控制台(例: -o -) 2. 恢复 mongorestore用法: mongorestore 常用配置: 同上 3. 其他方法有时别人会把整个MongoDB的数据文件发给你, 这种”备份”方式很不推荐, 因为这样很有可能在复制文件的时候有更新操作, 导致拿到的文件时不完整的, 从而无法恢复. 使用上述备份与恢复方法可以避免这个问题. 如果拿到的是数据文件: 首先看是否有.wt文件, 如果有, 则说明原始库用的是WiredTiger引擎, 如果你的MongoDB是3.2以上版本, 则默认就是WiredTiger引擎, 无需额外加参数. 如果没有.wt文件, 而是有xxx.ns和xxx.0 xxx.1等文件, 则说明用的是mmap引擎, 3.2一下版本默认就是这个引擎, 而3.2以上版本需要指定参数:–storageEngine=mmapv1 然后看文件夹中是不是每个数据库都有自己的子文件夹, 这将决定启动mongod的时候是否需要加参数–directoryperdb, 有子文件夹则需要加这个参数, MongoDB将会去相应的子文件夹中读取数据文件 最后别忘了加参数–dbpath用于指定你所拿到备库文件夹的路径","comments":true,"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://zxmantou.github.io/tags/MongoDB/"}]},{"title":"MongoDB增删改——我们所熟悉的操作","date":"2017-04-07T00:43:48.000Z","path":"2017/04/07/MongoDB2/","text":"MongoDB增删改——我们所熟悉的操作前面介绍了如何启动MongoDB以及用shell连接, 下面介绍一些我们在mysql中所熟悉的一些操作 创建数据库 MongoDB 创建数据库的语法格式如下： 1use DATABASE_NAME 如果数据库不存在，则创建数据库，否则切换到指定数据库。 演示 12345&gt; use zxmantouswitched to db zxmantou&gt; dbzxmantou&gt; 可见我们当前的db已经是zxmantou了, 使用**show dbs**命令查看数据库列表 1234&gt; show dbsadmin 0.000GBlocal 0.000GBtest 0.000GB 发现新增的数据库并不在其中. 要显示它，我们需要向 zxmantou 数据库插入一些数据。 12345678&gt; db.user.insert(&#123;name:&quot;zxmantou&quot;&#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; show dbsadmin 0.000GBlocal 0.000GBtest 0.000GBzxmantou 0.000GB&gt; 删除数据库 删除当前数据库，默认为 test, 下面实例中将删除我们新建的zxmantou库: 12345678910111213&gt; show dbsadmin 0.000GBlocal 0.000GBtest 0.000GBzxmantou 0.000GB&gt; dbzxmantou&gt; db.dropDatabase()&#123; &quot;dropped&quot; : &quot;zxmantou&quot;, &quot;ok&quot; : 1 &#125;&gt; show dbsadmin 0.000GBlocal 0.000GBtest 0.000GB 删除集合(删除数据表) 集合删除语法格式如下： 1db.COLLECTION_NAME.drop() 实例: 12345678&gt; use zxmantouswitched to db zxmantou&gt; show tablesuser&gt; db.user.drop()true&gt; show tables&gt; 插入文档(新增记录) MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下： 1db.COLLECTION_NAME.insert(document) 实例: 12345678910111213&gt; use zxmantouswitched to db zxmantou&gt; db.user.insert(&#123;... name:&quot;zxmantou&quot;,... age:&quot;27&quot;,... gender: &quot;male&quot;,... site: &quot;www.zhangyuxiaojiao.com&quot;... &#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; db.user.find()&#123; &quot;_id&quot; : ObjectId(&quot;58e4d75bbe3140034aeb2ba1&quot;), &quot;name&quot; : &quot;zxmantou&quot;, &quot;age&quot; : &quot;27&quot;, &quot;gender&quot; : &quot;male&quot;, &quot;site&quot; : &quot;www.zhangyuxiaojiao.com&quot; &#125;&gt; 以上实例中 user 是我们的集合名(数据表名)，如果该集合不在该数据库中， MongoDB 会自动创建该集合并插入文档(一行记录)。 更新文档(更新记录) MongoDB 使用 update() 和 save() 方法来更新集合中的文档。接下来让我们详细来看下两个函数的应用及其区别。 5.1 Update()方法: update() 方法用于更新已存在的文档。语法格式如下： 123456789db.COLLECTION_NAME.update( &lt;query&gt;, &lt;update&gt;, &#123; upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 参数说明： query : update的查询条件，类似sql update查询内where后面的。 update : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的 upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。 multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 writeConcern :可选，抛出异常的级别。 我们刚才已经插入了一条记录, 现在对其进行修改: 1234567891011121314&gt; db.user.find()&#123; &quot;_id&quot; : ObjectId(&quot;58e4d75bbe3140034aeb2ba1&quot;), &quot;name&quot; : &quot;zxmantou&quot;, &quot;age&quot; : &quot;27&quot;, &quot;gender&quot; : &quot;male&quot;, &quot;site&quot; : &quot;www.zhangyuxiaojiao.com&quot; &#125;&gt; db.user.update(&#123;&apos;name&apos;:&apos;zxmantou&apos;&#125;,&#123;$set:&#123;&apos;age&apos;:18&#125;&#125;)WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)&gt; db.user.find().pretty()&#123; &quot;_id&quot; : ObjectId(&quot;58e4d75bbe3140034aeb2ba1&quot;), &quot;name&quot; : &quot;zxmantou&quot;, &quot;age&quot; : 18, &quot;gender&quot; : &quot;male&quot;, &quot;site&quot; : &quot;www.zhangyuxiaojiao.com&quot;&#125;&gt; 可见年龄已经年轻到18岁啦~ 5.2 save() 方法 save() 方法通过传入的文档来替换已有文档。语法格式如下： 123456db.collection.save( &lt;document&gt;, &#123; writeConcern: &lt;document&gt; &#125; ) 参数说明： document : 文档数据。 writeConcern :可选，抛出异常的级别。 实例 以下实例中我们替换了 _id 为 58e4d75bbe3140034aeb2ba1 的文档数据： 1234567891011121314151617&gt; db.user.save(&#123;... &quot;_id&quot; : ObjectId(&quot;58e4d75bbe3140034aeb2ba1&quot;),... &quot;name&quot; : &quot;zhangyuxiaojiao&quot;,... &quot;gender&quot; : &quot;male&quot;,... &quot;age&quot; : &quot;27&quot;,... &quot;site&quot; : &quot;zxmantou.github.io&quot;... &#125;)WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)&gt; db.user.find().pretty()&#123; &quot;_id&quot; : ObjectId(&quot;58e4d75bbe3140034aeb2ba1&quot;), &quot;name&quot; : &quot;zhangyuxiaojiao&quot;, &quot;gender&quot; : &quot;male&quot;, &quot;age&quot; : &quot;27&quot;, &quot;site&quot; : &quot;zxmantou.github.io&quot;&#125;&gt; 更多实例 只更新第一条记录： 1db.col.update( &#123; &quot;count&quot; : &#123; $gt : 1 &#125; &#125; , &#123; $set : &#123; &quot;test2&quot; : &quot;OK&quot;&#125; &#125; ); 全部更新： 1db.col.update( &#123; &quot;count&quot; : &#123; $gt : 3 &#125; &#125; , &#123; $set : &#123; &quot;test2&quot; : &quot;OK&quot;&#125; &#125;,false,true ); 只添加第一条： 1db.col.update( &#123; &quot;count&quot; : &#123; $gt : 4 &#125; &#125; , &#123; $set : &#123; &quot;test5&quot; : &quot;OK&quot;&#125; &#125;,true,false ); 全部添加加进去: 1db.col.update( &#123; &quot;count&quot; : &#123; $gt : 5 &#125; &#125; , &#123; $set : &#123; &quot;test5&quot; : &quot;OK&quot;&#125; &#125;,true,true ); 全部更新： 1db.col.update( &#123; &quot;count&quot; : &#123; $gt : 15 &#125; &#125; , &#123; $inc : &#123; &quot;count&quot; : 1&#125; &#125;,false,true ); 只更新第一条记录： 1db.col.update( &#123; &quot;count&quot; : &#123; $gt : 10 &#125; &#125; , &#123; $inc : &#123; &quot;count&quot; : 1&#125; &#125;,false,false ); 删除文档(删除记录) remove() 方法的基本语法格式如下所示： 1234567db.collection.remove( &lt;query&gt;, &#123; justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 参数说明： query :（可选）删除的文档的条件。 justOne : （可选）如果设为 true 或 1，则只删除一个文档。 writeConcern :（可选）抛出异常的级别。 实例: 123456789101112&gt; db.user.find().pretty()&#123; &quot;_id&quot; : ObjectId(&quot;58e4d75bbe3140034aeb2ba1&quot;), &quot;name&quot; : &quot;zhangyuxiaojiao&quot;, &quot;gender&quot; : &quot;male&quot;, &quot;age&quot; : &quot;27&quot;, &quot;site&quot; : &quot;zxmantou.github.io&quot;&#125;&gt; db.user.remove(&#123;&apos;name&apos;:&apos;zhangyuxiaojiao&apos;&#125;)WriteResult(&#123; &quot;nRemoved&quot; : 1 &#125;)&gt; db.user.find().pretty()&gt; 如果你想删除所有数据，可以使用以下方式（类似常规 SQL 的 truncate 命令）： 1&gt;db.col.remove(&#123;&#125;) 查询文档(查询记录) 之前实例已经演示了通过find()方法来查询所有记录的方法, 下一篇内容中将详细介绍复杂的查询方法","comments":true,"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://zxmantou.github.io/tags/MongoDB/"}]},{"title":"MongoDB安装与启动","date":"2017-04-07T00:41:59.000Z","path":"2017/04/07/MongoDB1/","text":"MongoDB安装与启动 1. 安装1.1 windows版 点击https://www.mongodb.com/download-center?jmp=nav#community到mongodb官网上下载msi文件. 双击运行即可, 没有什么需要交代的. 1.2 Linux版 123curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.3.tgz # 下载tar -zxvf mongodb-linux-x86_64-3.4.3.tgz # 解压mv mongodb-linux-x86_64-3.4.3/ /usr/local/mongodb MongoDB 的可执行文件位于 bin 目录下，所以可以将其添加到 PATH 路径中： 1export PATH=/usr/local/mongodb/bin:$PATH 1.3 Mac版mac版有两种方式, 一种是跟linux一样, 下载地址在此.另一种是通过brew安装: 1sudo brew install mongodb 如果要安装支持 TLS/SSL 命令如下： 1sudo brew install mongodb --with-openssl 安装最新开发版本： 1sudo brew install mongodb --devel 2. 启动MongoDB服务(以windows为例)安装完后文件目录如下: 12345678910111213141516171819202122232425262728D:\\Program Files\\MongoDB\\Server&gt;tree /a /f文件夹 PATH 列表卷序列号为 000D-76A0D:.\\---3.4 | GNU-AGPL-3.0 | MPL-2 | README | THIRD-PARTY-NOTICES | \\---bin bsondump.exe libeay32.dll mongo.exe mongod.exe mongod.pdb mongodump.exe mongoexport.exe mongofiles.exe mongoimport.exe mongooplog.exe mongoperf.exe mongorestore.exe mongos.exe mongos.pdb mongostat.exe mongotop.exe ssleay32.dll 首先创建一个用于存放MongoDB数据的文件夹, 我创建了一个文件夹 F:\\mongodb, 然后定位到mongodb的bin文件夹, 执行命令 1mongod --dbpath=f:\\mongodb 其中dbpath则是用于指定存放数据的路径, 这样mongodb服务便启动了. 此时新开一个cmd, 输入mongo打开shell, 其实这个shell就是mongodb的客户端，同时也是一个js的编译器，默认连接的是“test”数据库。 1234567D:\\Program Files\\MongoDB\\Server\\3.4\\bin&gt;mongoMongoDB shell version v3.4.3connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.3&gt; dbtest&gt; 3. 访问控制注意开启MongoDB服务时有一个waring: 122017-04-05T18:45:08.793+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2017-04-05T18:45:08.793+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted. 这是由于服务启动的时候没有开启访问控制(认证、授权)，如果是在学习阶段可以忽略这个警告，生产环境则需要开启访问控制：1mongod --auth --dbpath=f:\\mongodb 添加用户(需要在没开启访问控制的时候操作): 12345678use admindb.createUser(... &#123;... user: &quot;test&quot;,... pwd: &quot;test&quot;,... roles: [ &#123; role: &quot;__system&quot;, db: &quot;admin&quot; &#125; ]... &#125;... ) 这时使用–auth开启服务, 执行: 1db.auth(&quot;test&quot;,&quot;test&quot;) 即可继续操作数据库了 4. MongoDb web 用户界面MongoDB 提供了简单的 HTTP 用户界面。 如果你想启用该功能，需要在启动的时候指定参数 –rest 。1mongod --dbpath=f:\\mongodb --rest MongoDB 的 Web 界面访问端口比服务的端口多1000。如果你的MongoDB运行端口使用默认的27017，你可以在端口号为28017访问web用户界面，即地址为：http://localhost:28017。","comments":true,"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://zxmantou.github.io/tags/MongoDB/"}]},{"title":"SpringMVC + Shiro 访问未授权页面时不跳转，页面打印抛异常","date":"2016-06-08T02:38:00.000Z","path":"2016/06/08/SpringMVC-Shiro-UnauthorizedException/","text":"描述：配置文件中配置了访问了未授权之后的跳转地址，但结果没能跳转过去，而是直接在页面上抛出未授权异常 分析原因：配置文件可能需要做额外的处理 最终解决方案： 方案1：12345678&lt;!-- 定义需要特殊处理的异常，用类名或完全路径名作为key，异常页名作为值 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;org.apache.shiro.authz.UnauthorizedException&quot;&gt;/Denied&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 方案2：不使用注解，而是用配置文件配置url的权限 12345678910111213141516&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;!-- Shiro的核心安全接口，这个属性是必须的 --&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;!-- 要求登录时的链接(登录页面地址)，非必须的属性，默认会自动寻找Web工程根目录下的&quot;/login.jsp&quot;页面 --&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/showLogin&quot;/&gt; &lt;!-- 登录成功后要跳转的连接(本例中此属性用不到，因为登录成功后的处理逻辑在LoginController里硬编码) --&gt; &lt;!-- &lt;property name=&quot;successUrl&quot; value=&quot;/&quot; &gt;&lt;/property&gt; --&gt; &lt;!-- 用户访问未对其授权的资源时，所显示的连接 但是使用注解的话这段不起作用，需要使用异常处理器重定向页面--&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/denied&quot;/&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /Admin=roles[admin] /Common=roles[user] &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 原因：shiro的源代码ShiroFilterFactoryBean.Java定义的filter必须满足filter instanceof AuthorizationFilter，只有perms，roles，ssl，rest，port才是属于AuthorizationFilter，而anon，authcBasic，auchc，user是AuthenticationFilter，所以unauthorizedUrl设置后页面不跳转Shiro注解模式下，登录失败与没有权限都是通过抛出异常。并且默认并没有去处理或者捕获这些异常。在SpringMVC下需要配置捕获相应异常来通知用户信息","comments":true,"tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://zxmantou.github.io/tags/springmvc/"},{"name":"shiro","slug":"shiro","permalink":"https://zxmantou.github.io/tags/shiro/"}]},{"title":"BigDecimal 乘法问题","date":"2016-05-17T08:50:20.000Z","path":"2016/05/17/BigDecimal-multiply/","text":"直接用我的代码和结果描述一下问题吧： 代码：12345678910/** * Created by zhangx-ae on 2016/5/17. */public class DemoTest &#123; public static void main(String[] args) &#123; BigDecimal a = new BigDecimal(1000000); BigDecimal b = a.multiply(new BigDecimal(0.21)); System.out.println(b); &#125;&#125; 结果： 1209999.9999999999922284388276239042170345783233642578125000000 我想要的结果是210000.00，应该如何处理结果呢？ 实际上这是BigDecimal将double转化为Bigdecimal时出的问题，这是因为0.21不能够精确的表示double值，使用BigDecimal将double转化为精确值的时候所得的结果就会是0.2099999999999999922284388276239042170345783233642578125，所以相乘以后结果会是那个样子。 将String转为BigDecimal的时候，字符串是多少，结果就是多少，因此想要将double类型的数据转为BigDecimal的时候，这样做也许才是你想要的结果： 1BigDecimal b = new BigDecimal(String.valueOf(0.21)); 结果： 1210000.00","comments":true,"tags":[{"name":"BigDecimal","slug":"BigDecimal","permalink":"https://zxmantou.github.io/tags/BigDecimal/"}]}]